---
title: "Ecological Networks (Bio 365): Simulating Network Robustness"
author: "Alessandro Vindigni"
date: "20/03/2020"
output: 
  html_document:
    df_print: paged
    theme: journal
  pdf_document: 
    latex_engine: xelatex
header-includes:
  - \usepackage{fontspec}
  - \usepackage{wrapfig}
  - \setmainfont{Arial}
  - \usepackage[fontsize=12pt]{scrextend}
  - \usepackage[labelfont=bf]{caption}
  - \pagenumbering{gobble}
  - \usepackage{booktabs}
  - \usepackage{sectsty} \sectionfont{\centering \emph}
  - \usepackage{tcolorbox}

---

```{r setup, include=FALSE}

library("tidyverse")
library("data.table")
library("repr")
library(imager)
library(dplyr) 
library(latex2exp)
library(knitr)
require(igraph)
require(ggplot2)
require(reshape2)
require(MEclustnet)
require(permute)
require(formatR)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff=60),tidy=TRUE)
knitr::opts_chunk$set(echo = FALSE)

setwd("~/ecological_networks_2020/20_march@vindigni/")

path_to_networks_data = "~/ecological_networks_2020/20_march@vindigni/Networks_data/"

source('~/ecological_networks_2020/20_march@vindigni/routines.R')
source('~/ecological_networks_2020/20_march@vindigni/uniform_connectivity.R')
source('~/ecological_networks_2020/20_march@vindigni/remove_bipartite.R')



```


```{r erdos_renyi, echo = FALSE}  
path_to_networks_data = "~/ecological_networks_2020/20_march@vindigni/Networks_data/"
load(paste0(path_to_networks_data, "erdos_renyi_RND.RData"))
load(paste0(path_to_networks_data, "erdos_renyi_MTL.RData"))
load(paste0(path_to_networks_data, "erdos_renyi_LTM.RData"))
load(paste0(path_to_networks_data, "s_cluster_k3.RData"))
```

```{r plant-pollinator, echo = FALSE} 
load(paste0(path_to_networks_data, "network_list_PL.RData"))
```

## Degree distribution

The average number of links per node is crucial property of a network. The  following figure shows three representative networks in which each node has *exactly* the same number of links $k$.
```{r, echo = FALSE, fig.width=8}
#, fig.height=6}
nets <- load.image('~/ecological_networks_2020/20_march@vindigni/fig_delta_k.png')
plot(nets, axes = FALSE)
```

In the networks drawn above there is no **heterogeneity**. Realistic networks -- such as www, internet, social networks or cells -- are, instead, featured by a finite degree of heterogeneity. This is quantified by the distribution of links per node, henceforth called *degree distribution*.
In the first part of this session we will learn that the robustness of a network is strongly affected by the form of the degree distribution.

### Erdos-Renyi model

Let us start considering the [Erdos-Renyi](https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model) model, which has been discussed during the classes held by Jordi Bascompte (click on the name for more details). In this text-book model, a network $G(n,p)$
is constructed starting from $n$ nodes and adding randomly links between them. Each link is included in the network with probability $p$ independent from other links. Therefore, the distribution of links $k$, i.e. the degree distribution, is expected to follow the binomial distribution
\begin{equation}
P(k) = \binom{n-1}{k} \, p^k\,(1-p)^{n-1-k}
\end{equation}
Note that for a given value of $n$ and $p$ many different Erdos-Renyi networks can be realized.

The next chunk of code reproduces and plots the degree distribution $P(k)$ for an Erdos-Renyi network built choosing
\begin{equation}
\label{a_definition}
p = \frac{a}{n}
\end{equation}
Adjust the value of the parameter $a$ till the average number of links per node $\langle k \rangle$ is approximately 3.
```{r plot_poisson, warning = FALSE}
set.seed(6)  # fixes the seed of the RND numbers generator to obtain always the same network
N1 = 1024
N2 = 100000

# CHANGE PARAMETERS HERE
a = 1.
data_er_1 <- erdos_reny_k_distribution(N1, a)
data_er_2 <- erdos_reny_k_distribution(N2, a)

k_average_er <- erdos_reny_k_ave(N1, a) %>% round(., digits = 3)

# data frame with all the annotation info
annotation_k3 <- data.frame(
  x = 4.2,
  y = 1,
  label = "k = 3"
)

annotation_er <- data.frame(
  x = 7,
  y = 0.25,
  label = paste0("ER with <k> = ", k_average_er)
)


ggplot() +
  ggtitle("Erdos-Renyi: 1024 (black), 100000 (purple)") +
  geom_point(data = data_er_1, aes(k, frequency), color = "blue",shape = 1) +
  geom_point(data = data_er_2, aes(k, frequency), color = "purple",shape = 1) +
  # Add segments
  annotate("segment", x = 3, xend = 3, y = 0, yend = 1, colour = "black", size=1, alpha=0.5) +
  # Add text
  geom_text(data=annotation_k3, aes( x=x, y=y, label=label),
            color="black",
            size=4 , angle=0) +
  geom_text(data=annotation_er, aes( x=x, y=y, label=label),
            color="blue",
            size=4 , angle=0) +
  ylab(TeX("$P(k)$")) +
  xlab(TeX("$k$"))


```

A distribution with no heterogeneity, corresponding to the network in the middle of Fig.1, is also visualized. In formula, this distribution reads
\[
\delta_{k,3} = \cases{& 1     if   k=3 \\ & 0     otherwise}
\]


## Progressive removal of nodes

An important property of **Erdos-Renyi** networks is that the size of the largest connected cluster $C_{max}$ scales differently with  the number of nodes $n$ depending on whether $\langle k \rangle$  is smaller or lager than 1, that is
\[
\begin{split}
&C_{max} \sim n    \quad &\langle k \rangle > 1\\
&C_{max} \sim \log(n)  \quad &\langle k \rangle < 1
\end{split}
\]

The quantity $C_{max}$ will be used as an **order parameter** to quantify the tolerance of a given network to the progressive removal of nodes, namely the network robustness.
In particular, nodes will be removed following three different strategies

1.  random removal -- RND

2. *systematic* removal from most to least connected node -- MTL

3. *systematic* removal from least to most connected node -- LTM


Referring to the a binomial degree distribution $P(k)$, the two *systematic* strategies proceed removing nodes as indicated by the arrows in the next figure

```{r plot_strategy, warning = FALSE, echo=FALSE}
set.seed(6)  # fixes the seed of the RND numbers generator to obtain always the same network
N1 = 1024
# What happens when you change a
a = 2.
data_er_1 <- erdos_reny_k_distribution(N1, a)

# data frame with all the annotation info
annotation_MTL <- data.frame(
  x = 2,
  y = 0.12,
  label = "MTL"
)

annotation_LTM <- data.frame(
  x = 2,
  y = 0.03,
  label = "LTM"
)

ggplot() +
  geom_point(data = data_er_1, aes(k, frequency), color = "blue",shape = 1) +
  # Add segments
  annotate("segment", x = 0, xend = 8, y = 0.05, yend = 0.05, colour = "green", size=1.5, alpha=0.5, arrow=arrow()) +
  annotate("segment", x = 8, xend = 0, y = 0.1, yend = 0.1, colour = "red", size=1.5, alpha=0.5, arrow=arrow()) +
  # Add text
  geom_text(data=annotation_MTL, aes( x=x, y=y, label=label),
            color="red",
            size=4 , angle=0, fontface="bold")  +
  geom_text(data=annotation_LTM, aes( x=x, y=y, label=label),
            color="green",
            size=4 , angle=0, fontface="bold")   +
  ylab(TeX("$P(k)$")) +
  xlab(TeX("$k$"))
```

Defining $N$ as the initial number of nodes in the network and $n$ as the *current* number during the removal of nodes,
we focus on the evolution of the largest cluster size $C_{max}(n)$ plotting its ratio with respect to  $C_{max}(N)$
\[
\frac{C_{max}(n)}{C_{max}(N)}
\]
To better compare results obtained for networks with different (initial) number of nodes $N$,
the order parameter $C_{max}$ is usually plotted as a function of the fraction of removed nodes
\[
f = 1- \frac{n}{N}
\]
We will adopt this convention and plot the average number of links  $\langle k \rangle$  as a function of $f$ along with $C_{max}$.

### Task
Replace the value of $a$ that you have previously determined to obtain $\langle k \rangle \simeq 3$
for the binomial distribution and run the underlying code:

```{r ER_robustness, warning = FALSE, echo=FALSE}

set.seed(6)  # seed of the RND # generator if i want to get always the same network
N= 1024
del_block = 20
iterations = 3

# CHANGE PARAMETERS HERE
a = 4
p = a/N
my_erdos_renyi <- erdos.renyi.game(N,p)

print(paste0("<k> = ", mean(degree(my_erdos_renyi))))

# I need to work with char so that vertices are not renamed
vertex_names <- length(V(my_erdos_renyi)) %>% seq(1,.) %>% toStringVec(.)
my_erdos_renyi <- my_erdos_renyi %>% set_vertex_attr("name", value = vertex_names)

largest_cluster_size(my_erdos_renyi)

s_cluster_rnd <- random_delete(my_erdos_renyi,iterations,del_block)
s_cluster_attack <- systematic_delete(my_erdos_renyi, iterations, TRUE, del_block)
s_cluster_least <- systematic_delete(my_erdos_renyi, iterations, FALSE, del_block)

s_cluster_rnd_data <-  data.frame(s_cluster_rnd)
names(s_cluster_rnd_data) <- c("deleted_nodes", "largest_cluster_size","k_average")

s_cluster_attack_data <- data.frame(s_cluster_attack)
names(s_cluster_attack_data) <- c("deleted_nodes", "largest_cluster_size","k_average")

s_cluster_least_data <- data.frame(s_cluster_least)
names(s_cluster_least_data) <- c("deleted_nodes", "largest_cluster_size","k_average")

# Ring k = 3 with this routine
graph_k <- unifrom_k3_matrix(N) %>% graph_from_adjacency_matrix(.,"undirected","upper")
print(paste0("<k> = ", mean(degree(graph_k))))
vertex_k <- length(V(graph_k)) %>% seq(1,.) %>% toStringVec(.)
graph_k <- graph_k %>% set_vertex_attr("name", value = vertex_k)
s_cluster_k <- random_delete(graph_k,iterations,del_block)
s_cluster_k_data <- data.frame(s_cluster_k)
names(s_cluster_k_data) <- c("deleted_nodes", "largest_cluster_size","k_average")

# plots
# annotation info 3 strategies
annotation_MTL <- data.frame(
  x = 0.19,
  y = 0.15,
  label = "MTL"
)

annotation_LTM <- data.frame(
  x = 0.9,
  y = 0.15,
  label = "LTM"
)

annotation_RND <- data.frame(
  x = 0.65,
  y = 0.15,
  label = "RND"
)

annotation_k3 <- data.frame(
  x = 0.45,
  y = 0.15,
  label = "k = 3"
)


ggplot() +
  ggtitle("Erdos-Renyi")+
  # ggtitle("k=4 relative S: rnd = blue square, attack = red circles")+
  geom_point(data = s_cluster_rnd_data, aes((deleted_nodes/N), largest_cluster_size), color = "blue",shape = 1) +
  geom_point(data = s_cluster_attack_data, aes((deleted_nodes/N), largest_cluster_size), color = "red", shape = 1) +
  geom_point(data = s_cluster_least_data, aes((deleted_nodes/N), largest_cluster_size), color = "green", shape = 1) +
  geom_point(data = s_cluster_k_data, aes((deleted_nodes/N), largest_cluster_size), color = "black", shape = 2) +
  # Add text
  geom_text(data=annotation_k3, aes( x=x, y=y, label=label),
            color="black",
            size=4 , angle=0) +
  geom_text(data=annotation_LTM, aes( x=x, y=y, label=label),
            color="green",
            size=4 , angle=0) +
  geom_text(data=annotation_MTL, aes( x=x, y=y, label=label),
            color="red",
            size=4 , angle=0) +
  geom_text(data=annotation_RND, aes( x=x, y=y, label=label),
            color="blue",
            size=4 , angle=0) +
  ylab(TeX("$C_{max}$")) +
  xlab(TeX("$f$"))


# plot k_average
ggplot() +
  geom_point(data = s_cluster_rnd_data, aes((deleted_nodes/N), k_average), color = "blue",shape = 1) +
  geom_point(data = s_cluster_least_data, aes((deleted_nodes/N), k_average), color = "green",shape = 1) +
  geom_point(data = s_cluster_attack_data, aes((deleted_nodes/N), k_average), color = "red",shape = 1) +
  geom_point(data = s_cluster_k_data, aes((deleted_nodes/N), k_average), color = "black",shape = 2) +
  # Add segments
  annotate("segment", x = 0, xend = 1, y = 1, yend = 1, colour = "black", size=0.7, alpha=0.5) +
  annotate("segment", x = 0, xend = 1, y = 2, yend = 2, colour = "black", size=0.7, alpha=0.5) +
  annotate("segment", x = 0, xend = 1, y = 3, yend = 3, colour = "black", size=0.7, alpha=0.5) +
  ylab(TeX("$< k >$")) +
  xlab(TeX("$f$"))

```

In both plots above, the black triangles correspond to an initial network with all nodes having connectivity $k=3$, namely $P(k) =\delta_{k,3}$. The other symbols correspond the three different strategies (RND, MTL, LTM) followed to remove nodes progressively
from the initial Erdos-Renyi network.

### Questions 

1. For the three different removal strategies (RND, MTL, LTM) 
the value of $C_{max}(n)/C_{max}(N)$ computed with the **Erdos-Renyi** model drops to zero in correspondence to a specific value of $\langle k \rangle$: which one?

```{r q1-answer, echo = TRUE}
# Enter answer as text. Remember to start answer with '#'


```

2. The critical values of $f$ for which $C_{max}$ drops to almost zero are a measure of the network **robustness**.  
In fact, when a sufficient number of nodes is removed so that $n$ becomes smaller than that threshold values $f_c$ 
the network dissolves into many small clusters. What is the relationship between the values of $f_c$  
obtained for the **Erdos-Renyi** network and the removal strategies adopted in the simulations? 
Referring to the general properties of **Erdos-Renyi** network summarized at the beginning of this section, 
provide an argument that relates the values of $f_c$  to the specific value of $\langle k \rangle$ that you have 
selected to answer question 1.? 

Values of $f_c$ obtained setting $a=2.9$ are reported in the table below for your convenience. 


```{r n_c_table, echo=FALSE}
n_c_values = c(660/1024,320/1024,940/1024) %>% round(., digits = 3)
strategies=c("RND","MTL","LTM")
data_removal <-data.frame(strategies,n_c_values)
names(data_removal) <- c("strategy","f<sub>c</sub>")
kable(data_removal)

```


```{r q2-answer, echo = TRUE}
# Enter answer as text. Remember to start answer with '#'


```

3. Even if for the network with $P(k) =\delta_{k,3}$ (no heterogeneity) only results for RND removal of nodes are displayed, the systematic strategies MTL and LTM produce the same results. Provide an argument to explain why some differences between the three removal strategies (RND, MTL, LTM) are observed only if the degree distribution $P(k)$ has a finite **heterogeneity**.  


```{r q3-answer, echo = TRUE}
# Enter answer as text. Remember to start answer with '#'


```



## Random graphs versus scale free networks 

The main goal of this section is to convince you that the **robustness** of a network is mostly affected by the degree of **heterogeneity** -- i.e., the variability in the number of links per node --  characterizing its degree distribution $P(k)$, rather than the average number of links per node $\langle k \rangle$. In fact,
in all the simulated networks we use $\langle k \rangle \simeq 3$ and still observe a remarkable difference in network resilience. 
The Poisson distribution -- characterizing the Erdos-Renyi model --  is not particularly suitable for this purpose because by choosing  the value of $p$ that
yields  $\langle k \rangle \simeq 3$ (for the initial network) also the variance of $P(k)$ gets fixed. 
Therefore, among the distributions $P(k)$ characterized by a maximum occurring at some finite value $k_0$ (not to be confused with $\langle k \rangle$!), in this section we choose to work with the Gaussian distribution, where both $k_0$ and the variance $\sigma$ can be adjusted,
to study the robustness of **random graphs**. To simulate **scale-free** networks we will assume a power-law degree distributions. 
In formulas these two degree distributions read
\[
P_{g} = P_{g,0} \exp\left[-\frac{(k-k_0)^2}{2\sigma^2}\right]
\qquad\qquad\qquad
P_{pl} = P_{pl, 0}\frac{1}{k^\gamma}
\]
$P_{g,0}$ and $P_{pl, 0}$ are constants adjusted in order that the probability is normalized to one, once the number nodes $N$ and the range of $k$ values to sample is chosen (note that depending of the choice of $\gamma$, $P_{pl}$ may not converge for $k\rightarrow \infty$). 

The two degree distributions $P_{g}$ and $P_{pl}$ can be visualized running the following chunk of code, where the vertical scale is logarithmic. 

```{r sf_gauss_dist, warning = FALSE}

set.seed(6)   # fixes the seed of the RND numbers generator to obtain always the same network

# CHANGE PARAMETERS HERE
N = 1024
gamma = 2.09 
sigma = 5 
k_0 = 50  

data_pl <- graph_scale_free(N,gamma) %>% graph_k_distribution()
k_average_pl <-graph_scale_free(N,gamma) %>% degree() %>% mean() %>% round(., digits = 3)

data_gauss <- graph_gauss(N, k_0, sigma) %>% graph_k_distribution()
k_average_gauss <- graph_gauss(N, k_0, sigma)  %>% degree() %>% mean() %>% round(., digits = 3)

annotation_pl <- data.frame(
x = 50,
y = 0.1,
label = paste0("power-law with <k> = ", k_average_pl)
)

annotation_gauss <- data.frame(
x = 50,
y = 0.04,
label = paste0("Gaussian  with <k> = ", k_average_gauss)
)

annotation_hubs <- data.frame(
x = 130,
y = 0.003,
label = "hubs"
)


ggplot() +
ggtitle("P(k): power-law versus Gaussian") +
geom_point(data = data_pl, aes(k, frequency), color = "blue",shape = 1) +
geom_point(data = data_gauss, aes(k, frequency), color = "purple",shape = 19) +
# Add segments
annotate("segment", x = 125, xend = 108, y = 0.0024, yend = 0.0011, colour = "black", size=1.2, alpha=0.7, 
arrow=arrow(ends="last", type = "closed")) +
annotate("segment", x = 135, xend = 175, y = 0.0024, yend = 0.0011, colour = "black", size=1.2, alpha=0.7, 
arrow=arrow(ends="last", type = "closed")) +
# Add text
geom_text(data=annotation_pl, aes( x=x, y=y, label=label),
      color="blue",
      size=4 , angle=0) +
geom_text(data=annotation_gauss, aes( x=x, y=y, label=label),
      color="purple",
      size=4 , angle=0) + 
      geom_text(data=annotation_hubs, aes( x=x, y=y, label=label),
      color="black",
      size=4 , angle=0) + 
scale_y_continuous(trans = "log10") + #+  xlim(0,40) +
  ylab(TeX("$P(k)$")) + 
  xlab(TeX("$k$"))

```

In the power-law distribution the value of $\gamma$ has been chosen to obtain  $\langle k \rangle \simeq 3$; the few highly connected nodes (hubs) have been indicated. 


### Tasks 
In the script that produces the figure above **adjust** the values of $\sigma$ and $k_0$ in order that the Gaussian distribution also produces  $\langle k \rangle \simeq 3$ (related to the next task). 
Describe the effect of changing the parameters $k_0$, $\sigma$, and $\gamma$?  
 
```{r q-answer_deg_dist, exercise = TRUE}
# Enter answer as text. Remember to start answer with '#'


```


The following code produces a plot of $C_{max}$ as a function of the fraction of removed nodes $f$ for
a network with a Gaussian ($P_{g}$) and power-law ($P_{pl}$) degree distributions, respectively.


**Run** the simulation (it takes a while!) keeping $\gamma = 2.09$ and inserting at the beginning of the code the values of
$k_0$ and $\sigma$ determined previously to obtain $\langle k \rangle \simeq 3$
(in case you did not complete the previous task, default values are suggested).


```{r power_law_vs_gauss_robustness, warning = FALSE, echo=FALSE}

# CHANGE PARAMETERS HERE

N=1024
gamma = 2.09  # power-law
sigma = 0.4 # Gauss
k_0 = 3.    # Gauss

del_block = 20
iterations = 3


graph_power_law <- graph_scale_free(N,gamma)
k_average_pl <-graph_scale_free(N,gamma) %>% degree() %>% mean() %>% round(., digits = 3)
print(paste0("power-law with <k> = ", k_average_pl))

my_graph_gauss <- graph_gauss(N, k_0, sigma)
k_average_gauss <- graph_gauss(N, k_0, sigma)  %>% degree() %>% mean() %>% round(., digits = 3)
print(paste0("Gaussian  with <k> = ", k_average_gauss))

#
# build power-law simulations and data frames
#
s_power_law_rnd <- random_delete(graph_power_law,iterations,del_block)
s_power_law_attack <- systematic_delete(graph_power_law, iterations, TRUE, del_block)
s_power_law_least <- systematic_delete(graph_power_law, iterations, FALSE, del_block)

s_power_law_rnd_data <-  data.frame(s_power_law_rnd)
names(s_power_law_rnd_data) <- c("deleted_nodes", "largest_cluster_size","k_average")

s_power_law_attack_data <- data.frame(s_power_law_attack)
names(s_power_law_attack_data) <- c("deleted_nodes", "largest_cluster_size","k_average")

s_power_law_least_data <- data.frame(s_power_law_least)
names(s_power_law_least_data) <- c("deleted_nodes", "largest_cluster_size","k_average")

#
# build Gaussian simulations and data frames
#
s_gauss_rnd <- random_delete(my_graph_gauss,iterations,del_block)
s_gauss_attack <- systematic_delete(my_graph_gauss, iterations, TRUE, del_block)
s_gauss_least <- systematic_delete(my_graph_gauss, iterations, FALSE, del_block)

s_gauss_rnd_data <-  data.frame(s_gauss_rnd)
names(s_gauss_rnd_data) <- c("deleted_nodes", "largest_cluster_size","k_average")

s_gauss_attack_data <- data.frame(s_gauss_attack)
names(s_gauss_attack_data) <- c("deleted_nodes", "largest_cluster_size","k_average")

s_gauss_least_data <- data.frame(s_gauss_least)
names(s_gauss_least_data) <- c("deleted_nodes", "largest_cluster_size","k_average")


# plots power-law
#
annotation_parameters_pl <- data.frame(
  x = 0.75,
  y = 0.75,
  label = paste0("gamma = ", gamma,  "   <k> = ", k_average_pl)
)
annotation_MTL_pl <- data.frame(
  x = 0.19,
  y = 0.25,
  label = "MTL"
)

annotation_LTM_pl <- data.frame(
  x = 0.9,
  y = 0.25,
  label = "LTM"
)

annotation_RND_pl <- data.frame(
  x = 0.6,
  y = 0.25,
  label = "RND"
)


ggplot() +
  ggtitle("power-law degree distribution") +
  geom_point(data = s_power_law_rnd_data, aes((deleted_nodes/N), largest_cluster_size), color = "blue",shape = 1) +
  geom_point(data = s_power_law_attack_data, aes((deleted_nodes/N), largest_cluster_size), color = "red", shape = 1) +
  geom_point(data = s_power_law_least_data, aes((deleted_nodes/N), largest_cluster_size), color = "green", shape = 1) +
  ylab(TeX("$C_{max}$")) +
  xlab(TeX("$f$")) +
  # # Add text
  geom_text(data=annotation_LTM_pl, aes( x=x, y=y, label=label),
            color="green",
            size=4 , angle=0) +
  geom_text(data=annotation_MTL_pl, aes( x=x, y=y, label=label),
            color="red",
            size=4 , angle=0) +
  geom_text(data=annotation_RND_pl, aes( x=x, y=y, label=label),
            color="blue",
            size=4 , angle=0) +
  geom_text(data=annotation_parameters_pl, aes( x=x, y=y, label=label),
            color="black",
            size=4 , angle=0)


# plots Gaussian
#
annotation_parameters_gauss <- data.frame(
  x = 0.75,
  y = 0.75,
  label = paste0("sigma = ", sigma,  "   <k> = ", k_average_gauss)
)

annotation_MTL_gauss <- data.frame(
  x = 0.19,
  y = 0.25,
  label = "MTL"
)

annotation_LTM_gauss <- data.frame(
  x = 0.7,
  y = 0.25,
  label = "LTM"
)

annotation_RND_gauss <- data.frame(
  x = 0.5,
  y = 0.25,
  label = "RND"
)


ggplot() +
  ggtitle("Gaussian degree distribution") +
  geom_point(data = s_gauss_rnd_data, aes((deleted_nodes/N), largest_cluster_size), color = "blue",shape = 1) +
  geom_point(data = s_gauss_attack_data, aes((deleted_nodes/N), largest_cluster_size), color = "red", shape = 1) +
  geom_point(data = s_gauss_least_data, aes((deleted_nodes/N), largest_cluster_size), color = "green", shape = 1) +
  ylab(TeX("$C_{max}$")) +
  xlab(TeX("$f$")) +
  # # Add text
  geom_text(data=annotation_LTM_gauss, aes( x=x, y=y, label=label),
            color="green",
            size=4 , angle=0) +
  geom_text(data=annotation_MTL_gauss, aes( x=x, y=y, label=label),
            color="red",
            size=4 , angle=0) +
  geom_text(data=annotation_RND_gauss, aes( x=x, y=y, label=label),
            color="blue",
            size=4 , angle=0) +
  geom_text(data=annotation_parameters_gauss, aes( x=x, y=y, label=label),
            color="black",
            size=4 , angle=0)
```

### Questions
1. Keeping $\gamma = 2.09$ and $k_0$ equal to the chosen value, repeat the simulation for
$\sigma = 5, 0.4, 0.1$. In which case  are the results obtained for the
Gaussian ($P_{g}$) and the scale-free  ($P_{pl}$)
degree distributions more similar?


```{r q1-gauss_vs_power_law, echo = TRUE}
# Enter answer as text. Remember to start answer with '#'


```

2. Assuming $\sigma<0.5$, which one of the two types of networks -- with degree distribution $P_{pl}(k)$ or $P_{g}(k)$  -- is more robust to systematic attack (MTL)? Explain with your own words why.


```{r q2-gauss_vs_power_law, echo = TRUE}
# Enter answer as text. Remember to start answer with '#'


```

3. The strategy of RND removal mimics failures in random networks, e.g., in the www or internet.
Still assuming $\sigma<0.5$, which one of the two types of networks -- with degree distribution $P_{pl}(k)$ or  $P_{g}(k)$ -- is more tollerant to failure? Explain with your own words why.


```{r q3-gauss_vs_power_law, echo = TRUE}
# Enter answer as text. Remember to start answer with '#'


```



## Tolerance to species extinction

We consider the 5 plant-pollinator *bipartite* networks available on [Web-Of-Life](http://www.web-of-life.es): **M_PL_015**, **M_PL_044**, **M_PL_054**, **M_PL_056**, **M_PL_062**.
We will access them from the list of networks downloaded on March 12 (behind the scene we load those data from the file "network_list_PL.RData").
The routine *"remove_plants()"* progressively removes plants following the three different strategies RND, MTL, LTM.
After each plant removal the routine checks if any pollinator is left without resources, in which case it is removed from the network. Therefore, a reduction of the plant species provokes **secondary extinctions** in the animals' community.
The relative amount of animal species that go extinct $f_{an}$ is returned as a function of the ratio of removed plants with respect to their initial number $f_{pl}$.

The routine *"remove_plants()"* takes the following ordered arguments

1. The network data, e.g., network_list_PL$M_PL_015

2. *iter* is the number of times the removal loop is repeated following different randomized sequences (iterations). Increasing *iter* should smoothen the curves; however,  increasing this parameter excessively you may reach the limit of allowed simulation time.

3. The type of removal strategy (character): "RND", "MTL", "LTM".

In the following simulations, an optimal default parameter set is chosen, but you are encouraged to experiment how results change by varying the computation parameters listed above. We proceed by producing the datasets of secondary extinction analysis for each individual network. Those data get stored in files.

__IF YOU HAVE COMPLETED THE TASKS INTERACTIVELY, THE DATA YOU PRODUCED WERE STORED IN FILES THAT WILL BE LOADED TO PRODUCE THE FOLLOWING PLOTS__

The data sets that you have simulated can be visualized running the underlying code.
```{r rubustness_3PL_networks, echo=FALSE}

NW_PL_015 <- column_to_rownames(network_list_PL$M_PL_015, var="V1")
load(paste0(path_to_networks_data, "rnd_data_PL_015.RData"))
num_plants_PL_015 <- nrow(NW_PL_015)   # number of rows
num_animals_PL_015 <- ncol(NW_PL_015)  # number of columns

NW_PL_044 <- column_to_rownames(network_list_PL$M_PL_044, var="V1")
load(paste0(path_to_networks_data, "rnd_data_PL_044.RData"))
num_plants_PL_044 <- nrow(NW_PL_044)   # number of rows
num_animals_PL_044 <- ncol(NW_PL_044)  # number of columns

NW_PL_054 <- column_to_rownames(network_list_PL$M_PL_054, var="V1")
load(paste0(path_to_networks_data, "rnd_data_PL_054.RData"))
num_plants_PL_054 <- nrow(NW_PL_054)   # number of rows
num_animals_PL_054 <- ncol(NW_PL_054)  # number of columns

NW_PL_056 <- column_to_rownames(network_list_PL$M_PL_056, var="V1")
load(paste0(path_to_networks_data, "rnd_data_PL_056.RData"))
num_plants_PL_056 <- nrow(NW_PL_056)   # number of rows
num_animals_PL_056 <- ncol(NW_PL_056)  # number of columns

NW_PL_062 <- column_to_rownames(network_list_PL$M_PL_062, var="V1")
load(paste0(path_to_networks_data, "rnd_data_PL_062.RData"))
num_plants_PL_062 <- nrow(NW_PL_062)   # number of rows
num_animals_PL_062 <- ncol(NW_PL_062)  # number of columns

annotation_PL_015 <- data.frame(
  x = 0.3,
  y = 0.45,
  label = paste0("M_PL_015: c = ", 0.034)
)

annotation_PL_062 <- data.frame(
  x = 0.3,
  y = 0.35,
  label = paste0("M_PL_062: c = ", 0.032)
)

annotation_PL_056 <- data.frame(
  x = 0.3,
  y = 0.25,
  label = paste0("M_PL_056: c = ", 0.026)
)

annotation_PL_054 <- data.frame(
  x = 0.3,
  y = 0.15,
  label = paste0("M_PL_054 c = ", 0.022)
)


annotation_PL_044 <- data.frame(
  x = 0.3,
  y = 0.05,
  label = paste0("M_PL_044 c = ", 0.017)
)




ggplot() +
 ggtitle("strategy: RND") +
  geom_point(data = rnd_data_PL_015, aes(removed_plants/num_plants_PL_015, (1- removed_animals/num_animals_PL_015)), color = "blue",shape = 1) +
  geom_point(data = rnd_data_PL_044, aes(removed_plants/num_plants_PL_044, (1- removed_animals/num_animals_PL_044)), color = "orange",shape = 1) +
  geom_point(data = rnd_data_PL_062, aes(removed_plants/num_plants_PL_062, (1- removed_animals/num_animals_PL_062)), color = "red",shape = 1) +
  geom_point(data = rnd_data_PL_054, aes(removed_plants/num_plants_PL_054, (1- removed_animals/num_animals_PL_054)), color = "purple",shape = 1) +
  geom_point(data = rnd_data_PL_056, aes(removed_plants/num_plants_PL_056, (1- removed_animals/num_animals_PL_056)), color = "green",shape = 1) +

  ylab(TeX("$f_{an}$")) +
  xlab(TeX("$f_{pl}$")) +
  # # Add text
  geom_text(data=annotation_PL_015, aes( x=x, y=y, label=label),
            color="blue",
            size=4 , angle=0) +
  geom_text(data=annotation_PL_044, aes( x=x, y=y, label=label),
            color="orange",
            size=4 , angle=0) +
  geom_text(data=annotation_PL_062, aes( x=x, y=y, label=label),
            color="red",
            size=4 , angle=0) +
  geom_text(data=annotation_PL_054, aes( x=x, y=y, label=label),
            color="purple",
            size=4 , angle=0) +
  geom_text(data=annotation_PL_056, aes( x=x, y=y, label=label),
            color="green",
            size=4 , angle=0)

```

For each network the **connectivity** is also indicated.
As a qualitative trend, networks with lower connectivity ($c < 0.003$) tend to be less resilient. However,
one cannot account for fine differences looking at the connectivity alone, because they generally originate from differences in the higher order structure of the networks, for instance from differences in the degree of **nestedness**.


In relation to the session of Daniel Wechsler, provide an argument to explain the role of nestedness in reinforcing the tolerance to species extinction in bipartite ecological networks (if it helps, you may **optionally** repeat the simulations changing the removal strategy from "RND" to "MTL" and "LTM").

```{r q-nestedness, echo = TRUE}
# Enter answer as text. Remember to start answer with '#'


```




